import type { MCPType, MCPInstance, MCPInstanceCreationResponse, APIKey, MCPLog } from '../types';
import { axiosGet, axiosPost, axiosPut, axiosDelete } from '../lib/axios';
import { config } from '../data/env';

const API_BASE_URL = '/api/v1';

const handleAxiosResponse = async <T>(response: any, endpoint?: string): Promise<T> => {
  if (!response.success) {
    throw new Error(response.error instanceof Error ? response.error.message : response.error || 'Request failed');
  }
  
  const data = response.data;
  console.log(`üîç Raw response from ${endpoint}:`, data);
  
  // For MCP creation responses, return the full response structure
  // to preserve both oauth and data fields
  if (data && (data.oauth || (data.data && data.data.instance_id))) {
    return data as T;
  }
  
  // Special handling for auth-registry validation responses
  // These have { success, message, data } structure that we need to preserve
  if (endpoint && endpoint.includes('/auth-registry/validate/')) {
    console.log('üîê Returning full auth validation response');
    return data as T;
  }
  
  // Check if the response has a data field (most API responses)
  if (data && data.data !== undefined) {
    console.log('üì¶ Extracting data field from response');
    return data.data as T;
  }
  
  // Otherwise, return the data directly
  return data as T;
};

const makeRequest = async <T>(
  endpoint: string,
  options: { method?: string; body?: any; headers?: Record<string, string> } = {}
): Promise<T> => {
  const url = `${API_BASE_URL}${endpoint}`;
  
  console.log('üì° makeRequest called:', { endpoint, method: options.method || 'GET', url });
  
  try {
    let response;
    
    switch (options.method?.toUpperCase()) {
      case 'POST':
        response = await axiosPost<T>(url, options.body ? JSON.parse(options.body) : {});
        break;
      case 'PUT':
        response = await axiosPut<T>(url, options.body ? JSON.parse(options.body) : {});
        break;
      case 'DELETE':
        response = await axiosDelete<T>(url);
        break;
      case 'GET':
      default:
        response = await axiosGet<T>(url);
        break;
    }
    
    return handleAxiosResponse<T>(response, endpoint);
  } catch (error) {
    console.error(`API request failed for ${endpoint}:`, error);
    throw error;
  }
};

export const apiService = {
  // MCP Types
  getMCPTypes: async (): Promise<MCPType[]> => {
    return makeRequest<MCPType[]>('/mcp-types?status=active');
  },

  getMCPTypeByName: async (name: string): Promise<MCPType> => {
    return makeRequest<MCPType>(`/mcp-types/${name}`);
  },

  // MCP Credentials Validation
  validateMCPCredentials: async (data: {
    mcp_type: string;
    credentials: Record<string, string>;
  }): Promise<{
    valid: boolean;
    message: string;
    service?: {
      name: string;
      type: string;
    };
  }> => {
    return makeRequest<{
      valid: boolean;
      message: string;
      service?: {
        name: string;
        type: string;
      };
    }>('/mcps/validate-credentials', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  // MCP Instances
  createMCP: async (data: {
    mcp_type: string;
    custom_name?: string;
    expiration_option: string;
    credentials: Record<string, string>;
    config?: Record<string, unknown>;
  }): Promise<MCPInstanceCreationResponse> => {
    return makeRequest<MCPInstanceCreationResponse>('/mcps', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  getMCPInstances: async (params?: {
    status?: string;
    mcp_type?: string;
    expiration_option?: string;
    page?: number;
    limit?: number;
    sort?: string;
    order?: string;
  }): Promise<MCPInstance[]> => {
    const searchParams = new URLSearchParams();
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          searchParams.append(key, value.toString());
        }
      });
    }
    
    const queryString = searchParams.toString();
    const endpoint = queryString ? `/mcps?${queryString}` : '/mcps';
    
    return makeRequest<MCPInstance[]>(endpoint);
  },

  getMCPInstance: async (id: string): Promise<MCPInstance> => {
    return makeRequest<MCPInstance>(`/mcps/${id}`);
  },

  renewMCP: async (id: string, data: {
    expires_at: string;
  }): Promise<{ id: string; status: string; expires_at: string; message: string }> => {
    return makeRequest<{ id: string; status: string; expires_at: string; message: string }>(`/mcps/${id}/renew`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  },

  toggleMCP: async (id: string, data: {
    status: 'active' | 'inactive';
  }): Promise<{ id: string; status: string; message: string }> => {
    return makeRequest<{ id: string; status: string; message: string }>(`/mcps/${id}/status`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  },

  editMCP: async (id: string, data: {
    custom_name?: string;
    credentials?: Record<string, string>;
  }): Promise<{ id: string; custom_name: string; message: string }> => {
    return makeRequest<{ id: string; custom_name: string; message: string }>(`/mcps/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  },

  updateMCPName: async (id: string, data: {
    custom_name: string;
  }): Promise<{ id: string; custom_name: string; message: string }> => {
    return makeRequest<{ id: string; custom_name: string; message: string }>(`/mcps/${id}/name`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  },

  updateMCPCredentials: async (id: string, data: {
    credentials: Record<string, string>;
  }): Promise<{ id: string; message: string }> => {
    return makeRequest<{ id: string; message: string }>(`/mcps/${id}/credentials`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
  },

  validateInstanceCredentials: async (id: string, data: {
    credentials: Record<string, string>;
  }): Promise<{
    valid: boolean;
    message: string;
    api_info?: {
      service: string;
      quota_remaining?: number;
      permissions?: string[];
    };
  }> => {
    return makeRequest<{
      valid: boolean;
      message: string;
      api_info?: {
        service: string;
        quota_remaining?: number;
        permissions?: string[];
      };
    }>(`/mcps/${id}/credentials/validate`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  deleteMCP: async (id: string): Promise<{
    message: string;
    instance_id: string;
    service_type: string;
    deleted_at: string;
    details: {
      instance_id: string;
      service_type: string;
      custom_name: string;
      user_id: string;
    };
  }> => {
    return makeRequest<{
      message: string;
      instance_id: string;
      service_type: string;
      deleted_at: string;
      details: {
        instance_id: string;
        service_type: string;
        custom_name: string;
        user_id: string;
      };
    }>(`/mcps/${id}`, {
      method: 'DELETE',
    });
  },

  // API Keys
  getAPIKeys: async (): Promise<APIKey[]> => {
    return makeRequest<APIKey[]>('/api-keys');
  },

  storeAPIKey: async (data: {
    mcp_type_id: string;
    credentials: Record<string, string>;
  }): Promise<APIKey> => {
    return makeRequest<APIKey>('/api-keys', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  validateCredentials: async (data: {
    mcp_type_id: string;
    credentials: Record<string, string>;
  }): Promise<{
    valid: boolean;
    message: string;
    api_info?: {
      service: string;
      quota_remaining?: number;
      permissions?: string[];
    };
  }> => {
    // Get MCP type to determine service name
    const mcpType = await apiService.getMCPTypeByName(data.mcp_type_id);
    const serviceName = mcpType.name.toLowerCase();

    // Use new auth registry validation endpoint
    try {
      console.log(`üîê Sending validation request to /auth-registry/validate/${serviceName}`, data.credentials);
      const result = await makeRequest<{
        success: boolean;
        message: string;
        data?: {
          userInfo?: any;
          service?: string;
          authType?: string;
        };
      }>(`/auth-registry/validate/${serviceName}`, {
        method: 'POST',
        body: JSON.stringify(data.credentials),
      });
      console.log(`‚úÖ Received validation response:`, result);

      // The response structure from backend is { success, message, data }
      // but makeRequest might have altered it
      const validationResult = result as any;
      const success = validationResult.success ?? validationResult.valid ?? false;
      const responseData = validationResult.data || validationResult;
      
      const response = {
        valid: success,
        message: validationResult.message || 'Validation completed',
        api_info: responseData.userInfo ? {
          service: serviceName,
          permissions: responseData.userInfo.permissions || ['read', 'write']
        } : undefined
      };
      console.log(`üì§ Returning formatted response:`, response);
      return response;
    } catch (error) {
      // If the request fails with a 200 OK but validation failed (success: false),
      // makeRequest will have already handled it. If we get here, it's a network/server error
      console.error('Validation request failed:', error);
      return {
        valid: false,
        message: error instanceof Error ? error.message : 'Validation failed',
        api_info: undefined
      };
    }
  },

  deleteAPIKey: async (id: string): Promise<void> => {
    return makeRequest<void>(`/api-keys/${id}`, {
      method: 'DELETE',
    });
  },

  // New Auth Registry endpoints
  getAuthServices: async (): Promise<{
    services: Array<{
      name: string;
      type: 'oauth' | 'apikey' | 'hybrid';
      functions: string[];
    }>;
    total: number;
    stats: any;
  }> => {
    return makeRequest<{
      services: Array<{
        name: string;
        type: 'oauth' | 'apikey' | 'hybrid';
        functions: string[];
      }>;
      total: number;
      stats: any;
    }>('/auth-registry/services', {
      method: 'GET',
    });
  },

  createOAuthInstance: async (serviceName: string, credentials: Record<string, string>): Promise<{
    success: boolean;
    authUrl?: string;
    state?: string;
    message?: string;
    data?: {
      instanceId?: string;
      authUrl?: string;
      state?: string;
    };
  }> => {
    return makeRequest<{
      success: boolean;
      authUrl?: string;
      state?: string;
      message?: string;
      data?: {
        instanceId?: string;
        authUrl?: string;
        state?: string;
      };
    }>(`/auth-registry/initiate-oauth/${serviceName}`, {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
  },

  createAPIKeyInstance: async (serviceName: string, instanceData: { credentials: Record<string, string>; customName?: string; metadata?: any }): Promise<{
    success: boolean;
    instanceId?: string;
    message?: string;
    data?: {
      instanceId?: string;
      serviceName?: string;
      customName?: string;
      status?: string;
      userInfo?: any;
    };
  }> => {
    return makeRequest<{
      success: boolean;
      instanceId?: string;
      message?: string;
      data?: {
        instanceId?: string;
        serviceName?: string;
        customName?: string;
        status?: string;
        userInfo?: any;
      };
    }>(`/auth-registry/create-instance/${serviceName}`, {
      method: 'POST',
      body: JSON.stringify(instanceData),
    });
  },

  revokeServiceInstance: async (serviceName: string, instanceId: string): Promise<{
    success: boolean;
    message: string;
  }> => {
    return makeRequest<{
      success: boolean;
      message: string;
    }>(`/auth-registry/revoke/${serviceName}/${instanceId}`, {
      method: 'DELETE',
    });
  },

  getAuthRegistryStats: async (): Promise<any> => {
    return makeRequest<any>('/auth-registry/stats', {
      method: 'GET',
    });
  },

  // Logs
  getMCPLogs: async (mcpId: string, params?: {
    start_time?: string;
    end_time?: string;
    level?: string;
    limit?: number;
    offset?: number;
  }): Promise<MCPLog[]> => {
    const searchParams = new URLSearchParams();
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          searchParams.append(key, value.toString());
        }
      });
    }
    
    const queryString = searchParams.toString();
    const endpoint = queryString ? `/mcps/${mcpId}/logs?${queryString}` : `/mcps/${mcpId}/logs`;
    
    return makeRequest<MCPLog[]>(endpoint);
  },

  exportMCPLogs: async (mcpId: string, data: {
    format: 'json' | 'csv' | 'txt';
    start_time?: string;
    end_time?: string;
    level?: 'debug' | 'info' | 'warn' | 'error';
  }) => {
    // For file downloads, we still need to use fetch to handle blob responses
    // But we need to add the auth header manually
    const token = localStorage.getItem(config.auth.jwtStorageKey);
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    const response = await fetch(`${API_BASE_URL}/mcps/${mcpId}/logs/export`, {
      method: 'POST',
      credentials: 'include',
      headers,
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`${errorData.error.code}: ${errorData.error.message}`);
    }

    // Get the blob and create object URL
    const blob = await response.blob();
    const download_url = window.URL.createObjectURL(blob);
    
    // Get filename from Content-Disposition header or generate one
    const contentDisposition = response.headers.get('Content-Disposition');
    let filename = `logs_${mcpId}_${new Date().toISOString().split('T')[0]}.${data.format}`;
    
    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename="([^"]+)"/);
      if (filenameMatch) {
        filename = filenameMatch[1];
      }
    }

    // Return export response metadata
    return {
      download_url,
      expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString(), // 1 hour from now
      size_bytes: blob.size,
      format: data.format,
      total_logs: 0, // This would need to be provided by the backend
      filename
    };
  },

  getAllMCPLogs: async (params?: {
    start_time?: string;
    end_time?: string;
    level?: string;
    limit?: number;
    offset?: number;
  }): Promise<MCPLog[]> => {
    // First get all MCP instances
    const mcps = await makeRequest<MCPInstance[]>('/mcps');
    
    // Then fetch logs for each MCP instance
    const allLogsPromises = mcps.map(async (mcp) => {
      try {
        const logs = await makeRequest<MCPLog[]>(`/mcps/${mcp.id}/logs`, {
          method: 'GET',
        });
        // Add MCP info to each log entry
        return logs.map(log => ({
          ...log,
          mcpId: mcp.id,
          mcpName: mcp.custom_name || `${mcp.mcp_type} MCP`
        }));
      } catch (error) {
        console.warn(`Failed to fetch logs for MCP ${mcp.id}:`, error);
        return [];
      }
    });
    
    // Wait for all promises and flatten the results
    const allLogsArrays = await Promise.all(allLogsPromises);
    const allLogs = allLogsArrays.flat();
    
    // Sort by timestamp (newest first)
    allLogs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    
    // Apply filters if provided
    let filteredLogs = allLogs;
    
    if (params?.level) {
      filteredLogs = filteredLogs.filter(log => log.level === params.level);
    }
    
    if (params?.start_time) {
      const startTime = new Date(params.start_time);
      filteredLogs = filteredLogs.filter(log => new Date(log.timestamp) >= startTime);
    }
    
    if (params?.end_time) {
      const endTime = new Date(params.end_time);
      filteredLogs = filteredLogs.filter(log => new Date(log.timestamp) <= endTime);
    }
    
    // Apply pagination
    if (params?.offset || params?.limit) {
      const start = params?.offset || 0;
      const end = params?.limit ? start + params.limit : undefined;
      filteredLogs = filteredLogs.slice(start, end);
    }
    
    return filteredLogs;
  },

  // User Plan
  getUserPlan: async (): Promise<{
    userId: string;
    plan: {
      type: string;
      maxInstances: number | null;
      features: any;
      expiresAt: string | null;
      createdAt: string;
    };
    isActive: boolean;
    activeInstances: number;
    maxInstances: number | null;
    canCreate: boolean;
    message: string;
    usage: {
      used: number;
      limit: number | string;
      remaining: number | string;
    };
  }> => {
    return makeRequest<{
      userId: string;
      plan: {
        type: string;
        maxInstances: number | null;
        features: any;
        expiresAt: string | null;
        createdAt: string;
      };
      isActive: boolean;
      activeInstances: number;
      maxInstances: number | null;
      canCreate: boolean;
      message: string;
      usage: {
        used: number;
        limit: number | string;
        remaining: number | string;
      };
    }>('/auth/plan');
  },

  // Billing & Subscription Management
  getBillingStatus: async (): Promise<{
    userId: string;
    plan: {
      type: 'free' | 'pro';
      maxInstances: number | null;
      paymentStatus: string;
      features: any;
      expiresAt: string | null;
      subscriptionId: string | null;
    };
    subscription?: any;
    canUpgrade: boolean;
  }> => {
    return makeRequest('/subscriptions/current');
  },

  createCheckoutSession: async (): Promise<{
    subscriptionId: string;
    amount: number;
    currency: string;
    customerId: string;
    razorpayKeyId: string;
    customerEmail: string;
    customerName: string;
    userId: string;
  }> => {
    return makeRequest('/billing/checkout', {
      method: 'POST'
    });
  },

  handleCheckoutSuccess: async (sessionId: string): Promise<{
    planType: string;
    paymentStatus: string;
    upgradedBy?: string;
    note?: string;
  }> => {
    return makeRequest('/billing/success', {
      method: 'POST',
      body: JSON.stringify({ sessionId })
    });
  },

  cancelSubscription: async (): Promise<{
    subscriptionId: string;
    cancelledAt: string;
    note: string;
  }> => {
    return makeRequest('/billing/cancel', {
      method: 'POST'
    });
  },

  getPaymentHistory: async (params?: { limit?: number; offset?: number }): Promise<{
    payments: Array<{
      id: string;
      amount: number;
      currency: string;
      status: string;
      method: string;
      cardLast4?: string;
      cardBrand?: string;
      createdAt: string;
      description: string;
    }>;
    total: number;
    hasMore: boolean;
  }> => {
    const queryParams = new URLSearchParams();
    if (params?.limit) queryParams.append('limit', params.limit.toString());
    if (params?.offset) queryParams.append('offset', params.offset.toString());
    
    const endpoint = queryParams.toString() 
      ? `/billing/payment-history?${queryParams.toString()}`
      : '/billing/payment-history';
    
    return makeRequest(endpoint);
  },

  getSubscriptionDetails: async (): Promise<{
    subscriptionId: string;
    planId: string;
    planName: string;
    amount: number;
    currency: string;
    interval: string;
    status: string;
    currentPeriodStart: string;
    currentPeriodEnd: string;
    nextBilling: string;
    cancelAtPeriodEnd: boolean;
    customerId: string;
    totalCount: number;
    paidCount: number;
    remainingCount: number;
    startedAt: string;
    createdAt: string;
    notes?: any;
  }> => {
    return makeRequest('/billing/subscription-details');
  },

  getRazorpaySavedCards: async (): Promise<{
    cards: Array<{
      id: string;
      last4: string;
      network: string;
      type: string;
      issuer?: string;
      expiryMonth: number;
      expiryYear: number;
      bank?: string;
      wallet?: string;
      method: string;
      createdAt: string;
    }>;
    customerId: string | null;
    count: number;
  }> => {
    return makeRequest('/billing/saved-cards');
  },

  // Generic HTTP methods for direct API calls
  get: async <T = any>(endpoint: string): Promise<T> => {
    return makeRequest<T>(endpoint, {
      method: 'GET'
    });
  },

  post: async <T = any>(endpoint: string, data?: any): Promise<T> => {
    return makeRequest<T>(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined
    });
  },

  put: async <T = any>(endpoint: string, data?: any): Promise<T> => {
    return makeRequest<T>(endpoint, {
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined
    });
  },

  delete: async <T = any>(endpoint: string): Promise<T> => {
    return makeRequest<T>(endpoint, {
      method: 'DELETE'
    });
  },

};