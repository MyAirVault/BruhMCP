/**
 * Global Variable Manager for Figma Response Deduplication
 * Reduces response size through variable extraction
 */

import { createHash } from 'crypto';

/**
 * @typedef {Object} VariableData
 * @property {string} _hash - Hash of the variable value
 * @property {string} _type - Type prefix of the variable
 * @property {*} [key] - Other properties from the original value
 */

/**
 * @typedef {Record<string, VariableData>} VariableCategory
 */

/**
 * @typedef {Object} VariableCategories
 * @property {VariableCategory} styles - Style variables
 * @property {VariableCategory} fills - Fill variables
 * @property {VariableCategory} strokes - Stroke variables
 * @property {VariableCategory} effects - Effect variables
 * @property {VariableCategory} layouts - Layout variables
 * @property {VariableCategory} textStyles - Text style variables
 */

/**
 * @typedef {Object} CounterCategories
 * @property {number} style - Style counter
 * @property {number} fill - Fill counter
 * @property {number} stroke - Stroke counter
 * @property {number} effect - Effect counter
 * @property {number} layout - Layout counter
 * @property {number} textStyle - Text style counter
 */

/**
 * @typedef {Object} CategoryMap
 * @property {string} style - Maps to textStyles
 * @property {string} fill - Maps to fills
 * @property {string} stroke - Maps to strokes
 * @property {string} effect - Maps to effects
 * @property {string} layout - Maps to layouts
 * @property {string} textStyle - Maps to textStyles
 */

/**
 * @typedef {Object} StatisticsResult
 * @property {number} totalVariables - Total number of variables
 * @property {Record<string, number>} categoryCounts - Count per category
 * @property {number} estimatedSavings - Estimated space savings
 */

/**
 * Manages global variables for deduplicating repeated content in Figma responses
 */
class GlobalVariableManager {
    constructor() {
        /** @type {VariableCategories} */
        this.variables = {
            styles: {},
            fills: {},
            strokes: {},
            effects: {},
            layouts: {},
            textStyles: {}
        };
        /** @type {CounterCategories} */
        this.counters = {
            style: 0,
            fill: 0,
            stroke: 0,
            effect: 0,
            layout: 0,
            textStyle: 0
        };
    }

    /**
     * Find existing variable or create new one for given value
     * @param {unknown} value - Value to store or find
     * @param {keyof CounterCategories} prefix - Variable type prefix
     * @returns {string|null} Variable ID
     */
    findOrCreateVariable(value, prefix) {
        if (!value || (typeof value === 'object' && value !== null && Object.keys(value).length === 0)) {
            return null;
        }

        // Generate hash for the value to check for duplicates
        const valueHash = this.generateHash(value);
        
        // Check if we already have this value
        const existingVariable = this.findExistingVariable(valueHash, prefix);
        if (existingVariable) {
            return existingVariable;
        }

        // Create new variable
        const variableId = this.generateVariableId(prefix);
        this.storeVariable(variableId, value, prefix, valueHash);
        
        return variableId;
    }

    /**
     * Find existing variable by hash
     * @param {string} hash - Value hash
     * @param {keyof CounterCategories} prefix - Variable type prefix
     * @returns {string|null} Variable ID if found
     */
    findExistingVariable(hash, prefix) {
        const categoryName = this.getCategoryName(prefix);
        const category = /** @type {VariableCategory} */ (this.variables[/** @type {keyof VariableCategories} */ (categoryName)]);
        
        for (const [varId, data] of Object.entries(category)) {
            if (data._hash === hash) {
                return varId;
            }
        }
        
        return null;
    }

    /**
     * Store variable in appropriate category
     * @param {string} variableId - Variable ID
     * @param {unknown} value - Value to store
     * @param {keyof CounterCategories} prefix - Variable type prefix
     * @param {string} hash - Value hash
     */
    storeVariable(variableId, value, prefix, hash) {
        const categoryName = this.getCategoryName(prefix);
        
        /** @type {VariableCategory} */ (this.variables[/** @type {keyof VariableCategories} */ (categoryName)])[variableId] = {
            ...(typeof value === 'object' && value !== null ? /** @type {Record<string, unknown>} */ (value) : {}),
            _hash: hash,
            _type: prefix
        };
    }

    /**
     * Generate unique variable ID
     * @param {keyof CounterCategories} prefix - Variable type prefix
     * @returns {string} Variable ID
     */
    generateVariableId(prefix) {
        this.counters[prefix] = (this.counters[prefix] || 0) + 1;
        return `${prefix}_${this.counters[prefix]}`;
    }

    /**
     * Generate hash for value deduplication
     * @param {unknown} value - Value to hash
     * @returns {string} Hash string
     */
    generateHash(value) {
        const normalizedValue = this.normalizeValue(value);
        return createHash('md5').update(JSON.stringify(normalizedValue)).digest('hex');
    }

    /**
     * Normalize value for consistent hashing
     * @param {unknown} value - Value to normalize
     * @returns {unknown} Normalized value
     */
    normalizeValue(value) {
        if (Array.isArray(value)) {
            return value.map(item => this.normalizeValue(item));
        }
        
        if (value && typeof value === 'object') {
            /** @type {Record<string, unknown>} */
            const normalized = {};
            // Sort keys for consistent hashing
            Object.keys(/** @type {Record<string, unknown>} */ (value)).sort().forEach(key => {
                if (key.startsWith('_')) return; // Skip internal properties
                normalized[key] = this.normalizeValue((/** @type {Record<string, unknown>} */ (value))[key]);
            });
            return normalized;
        }
        
        return value;
    }

    /**
     * Get category name for variable type
     * @param {keyof CounterCategories} prefix - Variable type prefix
     * @returns {keyof VariableCategories} Category name
     */
    getCategoryName(prefix) {
        /** @type {Record<keyof CounterCategories, keyof VariableCategories>} */
        const categoryMap = {
            'style': 'textStyles',
            'fill': 'fills',
            'stroke': 'strokes',
            'effect': 'effects',
            'layout': 'layouts',
            'textStyle': 'textStyles'
        };
        return categoryMap[prefix] || 'styles';
    }

    /**
     * Get variable by ID
     * @param {string} variableId - Variable ID
     * @returns {Record<string, unknown>|null} Variable value
     */
    getVariable(variableId) {
        for (const category of Object.values(this.variables)) {
            if (category[variableId]) {
                const { _hash, _type, ...value } = category[variableId];
                return value;
            }
        }
        return null;
    }

    /**
     * Get all variables organized by category
     * @returns {Record<string, Record<string, Record<string, unknown>>>} All variables
     */
    getAllVariables() {
        /** @type {Record<string, Record<string, Record<string, unknown>>>} */
        const result = {};
        
        for (const [categoryName, category] of Object.entries(this.variables)) {
            if (Object.keys(category).length > 0) {
                result[categoryName] = {};
                for (const [varId, data] of Object.entries(category)) {
                    const { _hash, _type, ...value } = data;
                    result[categoryName][varId] = value;
                }
            }
        }
        
        return result;
    }

    /**
     * Get statistics about variable usage
     * @returns {StatisticsResult} Usage statistics
     */
    getStatistics() {
        /** @type {StatisticsResult} */
        const stats = {
            totalVariables: 0,
            categoryCounts: {},
            estimatedSavings: 0
        };

        for (const [categoryName, category] of Object.entries(this.variables)) {
            const count = Object.keys(category).length;
            stats.categoryCounts[categoryName] = count;
            stats.totalVariables += count;
        }

        return stats;
    }

    /**
     * Clear all variables
     */
    clear() {
        this.variables = {
            styles: {},
            fills: {},
            strokes: {},
            effects: {},
            layouts: {},
            textStyles: {}
        };
        this.counters = {
            style: 0,
            fill: 0,
            stroke: 0,
            effect: 0,
            layout: 0,
            textStyle: 0
        };
    }
}

export { GlobalVariableManager };